datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id             String  @id @default(cuid())
  email          String  @unique
  username       String  @unique @default(cuid())
  firstName      String?
  lastName       String?
  profilePicture String?
  onboarded      Boolean @default(false)

  // Datetime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  assets     Asset[]
  categories Category[]
  notes      Note[]
  qrCodes    Qr[]
  scans      Scan[]

  @@unique([email, username])
}

model Asset {
  id                  String    @id @default(cuid())
  title               String
  description         String?
  mainImage           String?
  mainImageExpiration DateTime?

  // Datetime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  user       User          @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId     String
  category   Category?     @relation(fields: [categoryId], references: [id])
  categoryId String?
  notes      Note[]
  qrCodes    Qr[]
  reports    ReportFound[]
}

model Note {
  id      String @id @default(cuid())
  content String

  // Datetime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId  String
  asset   Asset  @relation(fields: [assetId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  assetId String
}

model Category {
  id          String  @id @default(cuid())
  name        String
  description String?
  color       String

  // DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  assets Asset[]
  user   User    @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId String
}

model Qr {
  id String @id @default(cuid())

  // Version of the QR code based on spec from Denso wave
  version Int @default(0)

  // Error correction level based on spec from Denso wave
  errorCorrection ErrorCorrection @default(L)

  // Relationships
  asset   Asset?  @relation(fields: [assetId], references: [id], onDelete: SetNull)
  assetId String?

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId String

  // DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  scans     Scan[]
}

// Stores a report for when a an asset is reported as found
model ReportFound {
  id      String @id @default(cuid())
  email   String
  content String

  // Datetime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  asset   Asset  @relation(fields: [assetId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  assetId String
}

enum ErrorCorrection {
  L
  M
  Q
  H
}

model Scan {
  id String @id @default(cuid())

  latitude  String?
  longitude String?

  userAgent String?

  // When a logged in user scanned the QR code, we store it here
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)
  userId String?

  qr   Qr?     @relation(fields: [qrId], references: [id], onDelete: SetNull)
  qrId String?

  // We also store the qrId as a raw string for reference is fhte qr is deleted
  rawQrId String

  // DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
